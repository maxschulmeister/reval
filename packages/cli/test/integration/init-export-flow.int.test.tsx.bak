import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { existsSync, readFileSync } from 'fs';
import React from 'react';
import { render } from 'ink-testing-library';
import { waitForComponentCompletion } from '../utils';
import Init from '../../src/commands/init.tsx';
import Export from '../../src/commands/export.tsx';
import { withTempDir, writeFiles } from '../utils';
import { completeProject } from '../fixtures';

// Mock @reval/core for integration tests
vi.mock('@reval/core', () => ({
  initializeDatabase: vi.fn().mockResolvedValue(undefined),
  exportRun: vi.fn(),
}));

import { initializeDatabase, exportRun } from '@reval/core';

const mockInitializeDatabase = vi.mocked(initializeDatabase);
const mockExportRun = vi.mocked(exportRun);

describe('Integration Tests', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('Init â†’ Export Flow', () => {
    it('init creates files, then export can write to the created directory structure', async () => {
      await withTempDir(async (tempDir) => {
        // Step 1: Initialize project
        const { lastFrame } = render(<Init options={{}} />);
        await waitForComponentCompletion(lastFrame);

        // Verify files were created
        expect(existsSync('reval.config.ts')).toBe(true);
        expect(existsSync('data/sample.csv')).toBe(true);
        expect(mockInitializeDatabase).toHaveBeenCalledWith(false);

        // Verify config content
        const configContent = readFileSync('reval.config.ts', 'utf8');
        expect(configContent).toContain('defineConfig');
        expect(configContent).toContain('./data/sample.csv');

        // Verify data content
        const dataContent = readFileSync('data/sample.csv', 'utf8');
        expect(dataContent).toContain('input,expected_output');
        expect(dataContent).toContain('capital of France');

        // Step 2: Mock export data and test export
        const mockExportData = JSON.stringify({
          id: 'test-run-123',
          executions: [
            { id: 'exec1', status: 'success', result: 'test result 1' },
            { id: 'exec2', status: 'success', result: 'test result 2' },
          ],
        }, null, 2);

        mockExportRun.mockResolvedValue(mockExportData);

        const { lastFrame } = render(
          <Export args={['test-run-123']} options={{ format: 'json', out: 'results.json' }} />
        );

        // Verify export completed
        const output = lastFrame();
        expect(output).toContain('Export completed!');
        expect(output).toContain('results.json');

        // Verify export file was created
        expect(existsSync('results.json')).toBe(true);
        const exportedContent = readFileSync('results.json', 'utf8');
        expect(JSON.parse(exportedContent)).toEqual(JSON.parse(mockExportData));

        expect(mockExportRun).toHaveBeenCalledWith('test-run-123', 'json');
      });
    });

    it('init with existing files requires --force', async () => {
      await withTempDir(async (tempDir) => {
        // Create existing project files
        writeFiles(completeProject);

        // Try to init without force
        const { lastFrame } = render(<Init options={{}} />);

        const output = lastFrame();
        expect(output).toContain('Error initializing project:');
        expect(output).toContain('already exist');
        expect(output).toContain('Use --force to overwrite');

        expect(mockInitializeDatabase).not.toHaveBeenCalled();
      });
    });

    it('init with --force overwrites existing files', async () => {
      await withTempDir(async (tempDir) => {
        // Create existing project files with different content
        writeFiles({
          'reval.config.ts': 'export default { old: "config" };',
          'data': {
            'sample.csv': 'old,data\n"value1","value2"',
          },
        });

        // Read initial content
        const oldConfigContent = readFileSync('reval.config.ts', 'utf8');
        expect(oldConfigContent).toContain('old: "config"');

        // Init with force
        const { lastFrame } = render(<Init options={{ force: true }} />);

        const output = lastFrame();
        expect(output).toContain('Project initialized successfully!');

        // Verify files were overwritten
        const newConfigContent = readFileSync('reval.config.ts', 'utf8');
        expect(newConfigContent).toContain('defineConfig');
        expect(newConfigContent).not.toContain('old: "config"');

        const newDataContent = readFileSync('data/sample.csv', 'utf8');
        expect(newDataContent).toContain('input,expected_output');
        expect(newDataContent).not.toContain('old,data');

        expect(mockInitializeDatabase).toHaveBeenCalledWith(true);
      });
    });

    it('export works with different formats in initialized project', async () => {
      await withTempDir(async (tempDir) => {
        // Initialize project first
        const { lastFrame } = render(<Init options={{}} />);
        await waitForComponentCompletion(lastFrame);

        // Test JSON export
        const jsonData = '{"id": "run1", "format": "json"}';
        mockExportRun.mockResolvedValue(jsonData);

        const { waitUntilExit: waitForJsonExport } = render(
          <Export args={['run1']} options={{ format: 'json' }} />
        );
        await waitForJsonExport();

        expect(existsSync('reval-export-run1ndef.json')).toBe(true);
        expect(mockExportRun).toHaveBeenCalledWith('run1', 'json');

        // Test CSV export
        const csvData = 'id,result\nrun2,success';
        mockExportRun.mockResolvedValue(csvData);

        const { waitUntilExit: waitForCsvExport } = render(
          <Export args={['run2']} options={{ format: 'csv' }} />
        );
        await waitForCsvExport();

        expect(existsSync('reval-export-run2ndef.csv')).toBe(true);
        expect(mockExportRun).toHaveBeenCalledWith('run2', 'csv');
      });
    });

    it('handles nested directory exports in initialized project', async () => {
      await withTempDir(async (tempDir) => {
        // Initialize project
        const { lastFrame } = render(<Init options={{}} />);
        await waitForComponentCompletion(lastFrame);

        // Export to nested path
        mockExportRun.mockResolvedValue('{"test": "data"}');

        const { lastFrame } = render(
          <Export args={['run123']} options={{ format: 'json', out: 'exports/nested/result.json' }} />
        );

        const output = lastFrame();
        expect(output).toContain('Export completed!');
        expect(output).toContain('exports/nested/result.json');

        // Note: In real filesystem, the directory creation would be handled by fs operations
        // In mocked environment, we just verify the path was used correctly
      });
    });
  });
});